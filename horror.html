<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NIGHT SHIFT: POWER GRID</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; color: #0f0; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 10; pointer-events: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            z-index: 100; box-shadow: 0 0 5px white;
        }
        #prompt { position: absolute; bottom: 25%; width: 100%; text-align: center; color: #fff; font-weight: bold; font-size: 20px; text-shadow: 2px 2px #000; }
        .stat { margin-bottom: 5px; background: rgba(0,20,0,0.8); padding: 8px; border: 1px solid #0f0; width: 220px; }
        
        /* Interaction Bar */
        #hold-container { position: absolute; bottom: 32%; left: 50%; transform: translateX(-50%); width: 200px; height: 10px; border: 2px solid #fff; display: none; }
        #hold-fill { height: 100%; background: #0f0; width: 0%; }

        #instruction { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #444; font-size: 12px; text-align: center; width: 100%; }
        #win-screen, #death-screen { position: fixed; inset: 0; display: none; z-index: 2000; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        #win-screen { background: #fff; color: #000; }
        #death-screen { background: #000; color: red; }
        button { padding: 15px 30px; cursor: pointer; font-family: inherit; margin-top: 10px; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="stat">TIME: <span id="time-display">12:00 AM</span></div>
        <div class="stat">SANITY: <span id="sanity-val">100</span>%</div>
        <div class="stat">GRID: <span id="power-val">STABLE</span></div>
    </div>

    <div id="hold-container"><div id="hold-fill"></div></div>

    <div id="win-screen">
        <h1>07:00 AM</h1>
        <h2>SHIFT COMPLETE</h2>
        <button onclick="location.reload()">RESTART</button>
    </div>

    <div id="death-screen">
        <h1>STATION COMPROMISED</h1>
        <button onclick="location.reload()" style="background:red; color:white; border:none;">RETRY</button>
    </div>

    <div id="crosshair"></div>
    <div id="prompt"></div>
    <div id="instruction">HOLD [E] TO REPAIR BREAKER<br>WASD: Move | F: Flashlight</div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';

        let scene, camera, renderer, raycaster;
        let isStarted = false, powerOn = true, sanity = 100, anomaly = false;
        let flashlightOn = true, gameTime = 0, holdTimer = 0; 
        let pitch = 0, yaw = 0, keys = {};
        let monitor, redButton, fuseBox, flashlight, monster;
        let walls = [], roomLights = [];

        const TOTAL_GAME_SECONDS = 240; 
        const REPAIR_TIME = 2.0; // Seconds to hold E

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x010101);
            scene.fog = new THREE.FogExp2(0x000000, 0.15);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            raycaster = new THREE.Raycaster();

            // Environment
            const wallMat = new THREE.MeshStandardMaterial({color: 0x151515});
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({color: 0x080808}));
            floor.rotation.x = -Math.PI/2;
            scene.add(floor);

            const ceiling = floor.clone();
            ceiling.position.y = 3;
            ceiling.rotation.x = Math.PI/2;
            scene.add(ceiling);

            const addWall = (x, z, w, d) => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, 3, d), wallMat);
                m.position.set(x, 1.5, z);
                scene.add(m);
                walls.push(new THREE.Box3().setFromObject(m));
            };

            // Layout
            addWall(0, -10, 20, 0.5);   
            addWall(-10, 0, 0.5, 20);  
            addWall(10, 0, 0.5, 20);   
            addWall(5, 5, 0.5, 10);    
            addWall(0, 5, 5, 0.5);     

            // Lights Around the Place
            const lightPositions = [
                {x: 0, z: -5}, {x: 0, z: 0}, {x: 7.5, z: 0}, {x: 7.5, z: 5}
            ];

            lightPositions.forEach(pos => {
                // Visual Light Fixture
                const fix = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 0.3), new THREE.MeshBasicMaterial({color: 0xffffff}));
                fix.position.set(pos.x, 2.95, pos.z);
                scene.add(fix);

                // Actual Light
                const pl = new THREE.PointLight(0xaaaaff, 0.8, 12);
                pl.position.set(pos.x, 2.5, pos.z);
                scene.add(pl);
                roomLights.push({light: pl, fixture: fix});
            });

            // Desk & Interactive
            const desk = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 1.2), new THREE.MeshStandardMaterial({color: 0x222222}));
            desk.position.set(0, 0.8, -9);
            scene.add(desk);

            monitor = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.5), new THREE.MeshBasicMaterial({color: 0x001100}));
            monitor.position.set(0, 1.25, -9.45);
            scene.add(monitor);

            redButton = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({color: 0x880000}));
            redButton.position.set(0.8, 0.9, -8.8);
            redButton.name = "RECALIBRATE";
            scene.add(redButton);

            fuseBox = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.8, 0.2), new THREE.MeshStandardMaterial({color: 0x444400}));
            fuseBox.position.set(9.7, 1.5, 0);
            fuseBox.rotation.y = -Math.PI/2;
            fuseBox.name = "BREAKER";
            scene.add(fuseBox);

            monster = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.5, 0.5), new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: true}));
            monster.position.set(0, -10, 0);
            scene.add(monster);

            flashlight = new THREE.SpotLight(0xffffff, 2, 20, 0.45, 0.25, 1);
            scene.add(flashlight);
            scene.add(flashlight.target);

            camera.position.set(0, 1.6, -5);

            document.body.addEventListener('mousedown', () => {
                if(!isStarted) isStarted = true;
                document.body.requestPointerLock();
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body) {
                    yaw -= e.movementX * 0.002;
                    pitch -= e.movementY * 0.002;
                    pitch = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, pitch));
                    camera.rotation.set(pitch, yaw, 0, 'YXZ');
                }
            });

            document.addEventListener('keydown', (e) => { 
                keys[e.code] = true; 
                if(e.key.toLowerCase() === 'f') flashlightOn = !flashlightOn;
            });
            document.addEventListener('keyup', (e) => { keys[e.code] = false; });

            animate();
        }

        function updateUI(dt) {
            gameTime += dt;
            const progress = Math.min(gameTime / TOTAL_GAME_SECONDS, 1);
            const totalMins = progress * (7 * 60);
            let h = 12 + Math.floor(totalMins / 60);
            if (h > 12) h -= 12;
            const m = Math.floor(totalMins % 60);
            
            document.getElementById('time-display').innerText = `${h}:${m.toString().padStart(2, '0')} AM`;
            document.getElementById('sanity-val').innerText = Math.floor(sanity);
            document.getElementById('power-val').innerText = powerOn ? "STABLE" : "OFFLINE";
            document.getElementById('power-val').style.color = powerOn ? "#0f0" : "red";

            if (progress >= 1) {
                document.getElementById('win-screen').style.display = 'flex';
                isStarted = false;
                document.exitPointerLock();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isStarted) return;

            const dt = 1/60; 
            updateUI(dt);

            // Movement
            let dirZ = (keys['KeyW'] ? -1 : 0) + (keys['KeyS'] ? 1 : 0);
            let dirX = (keys['KeyA'] ? -1 : 0) + (keys['KeyD'] ? 1 : 0);
            if(dirZ !== 0 || dirX !== 0) {
                const moveVec = new THREE.Vector3(dirX, 0, dirZ).normalize();
                moveVec.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yaw));
                const nextPos = camera.position.clone().addScaledVector(moveVec, 0.08);
                let canMove = true;
                const pBox = new THREE.Box3().setFromCenterAndSize(nextPos, new THREE.Vector3(0.6, 2, 0.6));
                for(let wall of walls) if(pBox.intersectsBox(wall)) canMove = false;
                if(canMove) camera.position.copy(nextPos);
            }

            // Power System & Flicker
            if(Math.random() < 0.0005 && powerOn) powerOn = false;
            if(Math.random() < 0.001 && powerOn && !anomaly) anomaly = true;

            roomLights.forEach(rl => {
                if(!powerOn) {
                    rl.light.intensity = 0;
                    rl.fixture.material.color.set(0x222222);
                } else {
                    rl.light.intensity = 0.8 + (Math.random() * 0.1); // Subtle buzz
                    rl.fixture.material.color.set(0xffffff);
                }
            });

            // Interaction Raycast
            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects(scene.children);
            const prompt = document.getElementById('prompt');
            const holdBar = document.getElementById('hold-container');
            const holdFill = document.getElementById('hold-fill');
            
            let lookingAt = hits.length > 0 ? hits[0].object : null;

            if(lookingAt && lookingAt.name === "RECALIBRATE" && anomaly) {
                prompt.innerText = "[E] RECALIBRATE";
                if(keys['KeyE']) { anomaly = false; monitor.material.color.set(0x001100); }
            } else if(lookingAt && lookingAt.name === "BREAKER" && !powerOn) {
                prompt.innerText = "HOLD [E] TO REPAIR";
                holdBar.style.display = 'block';
                if(keys['KeyE']) {
                    holdTimer += dt;
                    holdFill.style.width = (holdTimer / REPAIR_TIME) * 100 + "%";
                    if(holdTimer >= REPAIR_TIME) {
                        powerOn = true;
                        holdTimer = 0;
                    }
                } else {
                    holdTimer = Math.max(0, holdTimer - dt * 2); // Progress loss
                    holdFill.style.width = (holdTimer / REPAIR_TIME) * 100 + "%";
                }
            } else {
                prompt.innerText = "";
                holdBar.style.display = 'none';
                holdTimer = 0;
            }

            // Horror Logic
            if(!powerOn || anomaly) sanity -= 0.1;
            else if(sanity < 100) sanity += 0.02;
            if(anomaly) monitor.material.color.set(0xaa0000);

            if(sanity < 50) {
                monster.position.y = 1.25;
                const toPlayer = new THREE.Vector3().subVectors(camera.position, monster.position).normalize();
                monster.position.addScaledVector(toPlayer, 0.02);
                if(camera.position.distanceTo(monster.position) < 1.2) sanity = 0;
            } else { monster.position.y = -10; }

            // Flashlight
            flashlight.position.copy(camera.position);
            const tPos = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            flashlight.target.position.copy(camera.position).add(tPos);
            flashlight.intensity = flashlightOn ? (powerOn ? 2.5 : 1.5) : 0;

            if(sanity <= 0) {
                document.getElementById('death-screen').style.display = 'flex';
                isStarted = false;
                document.exitPointerLock();
            }

            renderer.render(scene, camera);
        }
        window.onload = init;
    </script>
</body>
</html>